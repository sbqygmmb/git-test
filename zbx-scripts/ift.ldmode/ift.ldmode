#!/usr/bin/env ruby

=begin
Script: ift.ldmode
Version: 1.0
Author: Jean-Jacques MartrÃ¨s (jjmartres |at| gmail |dot| com)
Description: This script query ldOpModes OID from the Infortrend MIB (IFT-SNMP-MIB) to get the logical drive operating mode
License: GPL2

This script is intended for use with Zabbix > 2.0

USAGE:
 as a script:          ift.ldmode [options]
 as an item:           ift.ldmode["-d","IP_ADDRESS","-c","SNMP_COMMUNITY","-i","LD_INDEX"]

OPTIONS
    -h, --help                       Display this help message
    -d, --device IP_ADDRESS          Device IP address discovered by Zabbix
    -c, --community SNMP_COMMUNITY   SNMP community used for the device
    -i, --id LD_INDEX                Logical drive index
=end
require 'rubygems'
require 'optparse'
require 'snmp'

version="0.0.1"

# Howto use it..quiet simple
OPTIONS = {}
mandatory_options=[:deviceip, :community, :id]
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.separator ""
  opts.separator "Options"
  opts.on("-h", "--help", "Display this help message") do
    puts opts
    exit(-1)
  end
  opts.on('-d', '--device IP_ADDRESS', String, 'Device IP address discovered by Zabbix') { |v| OPTIONS[:deviceip] = v }
  opts.on('-c', '--community SNMP_COMMUNITY',String, 'SNMP community used for the device') { |v| OPTIONS[:community] = v }
  opts.on('-i', '--id LD_INDEX', Integer, 'Logical drive index') { |v| OPTIONS[:id] = v }
  opts.separator ""
end

# Show usage when no args pass
if ARGV.empty?
  puts optparse
  exit(-1)
end

# Validate that mandatory parameters are specified
begin
  optparse.parse!(ARGV)
  missing = mandatory_options.select{|p| OPTIONS[p].nil? }
  if not missing.empty?
    puts "Missing options: #{missing.join(', ')}"
    puts optparse
    exit(-1)
  end
  rescue OptionParser::ParseError,OptionParser::InvalidArgument,OptionParser::InvalidOption
       puts $!.to_s
       exit(-1)
end

# Query SNMP OID ldOpModes
oid_value = Array.new

SNMP::Manager.open(:host => OPTIONS[:deviceip], :community => OPTIONS[:community], :version => :SNMPv2c) do |manager|
  response = manager.get(["1.3.6.1.4.1.1714.1.1.2.1.5.#{OPTIONS[:id]}"])
  response.each_varbind do |vb|
   oid_value.push(vb.value.to_s)
  end
end

if oid_value.any?
  if oid_value[0].match('noSuchInstance')
    puts "-- ERROR -- : No such instance !"
  else
    # We need to read BITS 0-3 to get RAID LEVEL
    # 0 (0000 in binary): Single drive
    # 1 (0001 in binary): NON-RAID
    # 2 (0010 in binary): RAID0
    # 3 (0011 in binary): RAID1
    # 4 (0100 in binary): RAID3
    # 5 (0101 in binary): RAID4
    # 6 (0110 in binary): RAID5
    # 7 (0111 in binary): RAID6
    oid_value = oid_value[0].to_i
    ldOpMode = oid_value.to_s(2).to_s.split('').reverse
    ldOpMode = ldOpMode[0..3].reverse.to_s
    puts ldOpMode.to_i
    exit(-1)
  end
else
  puts "-- ERROR -- : No response receive from #{OPTIONS[:deviceip]} !"
  exit(-1)
end
